"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const C=require("node:path"),n=require("node:fs"),o=require("node:util"),_=require("fs-extra"),w={},p=(t,e)=>function(...i){return t.apply(void 0,i).catch(e)},E=(t,e)=>function(...i){try{return t.apply(void 0,i)}catch(c){return e(c)}},U=w.getuid?!w.getuid():!1,$=1e4,l=()=>{},s={isChangeErrorOk:t=>{if(!s.isNodeError(t))return!1;const{code:e}=t;return e==="ENOSYS"||!U&&(e==="EINVAL"||e==="EPERM")},isNodeError:t=>t instanceof Error,isRetriableError:t=>{if(!s.isNodeError(t))return!1;const{code:e}=t;return e==="EMFILE"||e==="ENFILE"||e==="EAGAIN"||e==="EBUSY"||e==="EACCESS"||e==="EACCES"||e==="EACCS"||e==="EPERM"},onChangeError:t=>{if(!s.isNodeError(t))throw t;if(!s.isChangeErrorOk(t))throw t}};class j{constructor(){this.interval=25,this.intervalId=void 0,this.limit=$,this.queueActive=new Set,this.queueWaiting=new Set,this.init=()=>{this.intervalId||(this.intervalId=setInterval(this.tick,this.interval))},this.reset=()=>{this.intervalId&&(clearInterval(this.intervalId),delete this.intervalId)},this.add=e=>{this.queueWaiting.add(e),this.queueActive.size<this.limit/2?this.tick():this.init()},this.remove=e=>{this.queueWaiting.delete(e),this.queueActive.delete(e)},this.schedule=()=>new Promise(e=>{const r=()=>this.remove(i),i=()=>e(r);this.add(i)}),this.tick=()=>{if(!(this.queueActive.size>=this.limit)){if(!this.queueWaiting.size)return this.reset();for(const e of this.queueWaiting){if(this.queueActive.size>=this.limit)break;this.queueWaiting.delete(e),this.queueActive.add(e),e()}}}}}const W=new j,g=(t,e)=>function(i){return function c(...y){return W.schedule().then(m=>{const d=S=>(m(),S),h=S=>{if(m(),Date.now()>=i)throw S;if(e(S)){const I=Math.round(100*Math.random());return new Promise(R=>setTimeout(R,I)).then(()=>c.apply(void 0,y))}throw S};return t.apply(void 0,y).then(d,h)})}},b=(t,e)=>function(i){return function c(...y){try{return t.apply(void 0,y)}catch(m){if(Date.now()>i)throw m;if(e(m))return c.apply(void 0,y);throw m}}},a={attempt:{chmod:p(o.promisify(n.chmod),s.onChangeError),chown:p(o.promisify(n.chown),s.onChangeError),close:p(o.promisify(n.close),l),fsync:p(o.promisify(n.fsync),l),mkdir:p(o.promisify(n.mkdir),l),realpath:p(o.promisify(n.realpath),l),stat:p(o.promisify(n.stat),l),unlink:p(o.promisify(n.unlink),l),chmodSync:E(n.chmodSync,s.onChangeError),chownSync:E(n.chownSync,s.onChangeError),closeSync:E(n.closeSync,l),existsSync:E(n.existsSync,l),fsyncSync:E(n.fsync,l),mkdirSync:E(n.mkdirSync,l),realpathSync:E(n.realpathSync,l),statSync:E(n.statSync,l),unlinkSync:E(n.unlinkSync,l)},retry:{close:g(o.promisify(n.close),s.isRetriableError),fsync:g(o.promisify(n.fsync),s.isRetriableError),open:g(o.promisify(n.open),s.isRetriableError),readFile:g(o.promisify(n.readFile),s.isRetriableError),rename:g(o.promisify(n.rename),s.isRetriableError),stat:g(o.promisify(n.stat),s.isRetriableError),write:g(o.promisify(n.write),s.isRetriableError),writeFile:g(o.promisify(n.writeFile),s.isRetriableError),closeSync:b(n.closeSync,s.isRetriableError),fsyncSync:b(n.fsyncSync,s.isRetriableError),openSync:b(n.openSync,s.isRetriableError),readFileSync:b(n.readFileSync,s.isRetriableError),renameSync:b(n.renameSync,s.isRetriableError),statSync:b(n.statSync,s.isRetriableError),writeSync:b(n.writeSync,s.isRetriableError),writeFileSync:b(n.writeFileSync,s.isRetriableError)}},B="utf8",N=438,G=511,P={},L={},z=w.userInfo().uid,J=w.userInfo().gid,q=7500,Q=!!w.getuid;w.getuid&&w.getuid();const T=128,Y=t=>t instanceof Error&&"code"in t,H=t=>typeof t=="function",D=t=>typeof t=="string",F=t=>t===void 0,v={},O={next:t=>{const e=v[t];if(!e)return;e.shift();const r=e[0];r?r(()=>O.next(t)):delete v[t]},schedule:t=>new Promise(e=>{let r=v[t];r||(r=v[t]=[]),r.push(e),!(r.length>1)&&e(()=>O.next(t))})};class V{constructor(){this.callbacks=new Set,this.exit=()=>{for(const e of this.callbacks)e()},this.hook=()=>{window.addEventListener("beforeunload",this.exit)},this.register=e=>(this.callbacks.add(e),()=>{this.callbacks.delete(e)}),this.hook()}}const X=new V,K=X.register,u={store:{},create:t=>{const e=`000000${Math.floor(Math.random()*16777215).toString(16)}`.slice(-6),c=`.tmp-${Date.now().toString().slice(-10)}${e}`;return`${t}${c}`},get:(t,e,r=!0)=>{const i=u.truncate(e(t));return i in u.store?u.get(t,e,r):(u.store[i]=r,[i,()=>delete u.store[i]])},purge:t=>{u.store[t]&&(delete u.store[t],a.attempt.unlink(t))},purgeSync:t=>{u.store[t]&&(delete u.store[t],a.attempt.unlinkSync(t))},purgeSyncAll:()=>{for(const t in u.store)u.purgeSync(t)},truncate:t=>{const e=C.basename(t);if(e.length<=T)return t;const r=/^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(e);if(!r)return t;const i=e.length-T;return`${t.slice(0,-e.length)}${r[1]}${r[2].slice(0,-i)}${r[3]}`}};K(u.purgeSyncAll);function k(t,e=P){if(D(e))return k(t,{encoding:e});const r=Date.now()+((e.timeout??q)||-1);return a.retry.readFile(r)(t,e)}function x(t,e,r,i){if(H(r))return x(t,e,L,r);const c=M(t,e,r);return i&&c.then(i,i),c}async function M(t,e,r=L){if(D(r))return M(t,e,{encoding:r});const i=Date.now()+((r.timeout??q)||-1);let c=null,y=null,m=null,d=null,h=null;try{r.schedule&&(c=await r.schedule(t)),y=await O.schedule(t);const S=await a.attempt.realpath(t),I=!!S;t=S||t,[d,m]=u.get(t,r.tmpCreate||u.create,r.tmpPurge!==!1);const A=Q&&F(r.chown),R=F(r.mode);if(I&&(A||R)){const f=await a.attempt.stat(t);f&&(r={...r},A&&(r.chown={uid:f.uid,gid:f.gid}),R&&(r.mode=f.mode))}if(!I){const f=C.dirname(t);await a.attempt.mkdir(f,{mode:G,recursive:!0})}h=await a.retry.open(i)(d,"w",r.mode||N),r.tmpCreated&&r.tmpCreated(d),D(e)?await a.retry.write(i)(h,e,0,r.encoding||B):F(e)||await a.retry.write(i)(h,e,0,e.length,0),r.fsync!==!1&&(r.fsyncWait!==!1?await a.retry.fsync(i)(h):a.attempt.fsync(h)),await a.retry.close(i)(h),h=null,r.chown&&(r.chown.uid!==z||r.chown.gid!==J)&&await a.attempt.chown(d,r.chown.uid,r.chown.gid),r.mode&&r.mode!==N&&await a.attempt.chmod(d,r.mode);try{await a.retry.rename(i)(d,t)}catch(f){if(!Y(f)||f.code!=="ENAMETOOLONG")throw f;await a.retry.rename(i)(d,u.truncate(t))}m(),d=null}finally{h&&await a.attempt.close(h),d&&u.purge(d),c&&c(),y&&y()}}const Z={array:()=>Array(),string:()=>String(),number:()=>Number()};class ee{scheme;db_path;constructor(e,r){this.scheme=e,this.db_path=r||process.cwd()}getDBPath(){return w.join(this.db_path,"database.json")}async get_db(){const e=this.getDBPath();if(await _.ensureFile(e),!await _.pathExists(e))throw new Error("failed to create db file");try{return JSON.parse(await k(e,"utf8"))}catch{}return Object()}async save_db(e){const r=this.getDBPath(),i=w.join(r,"..","database_bak.json");await _.pathExists(r)&&await _.copyFile(r,i),await x(r,JSON.stringify(e));try{JSON.parse(await k(r,"utf8"))}catch(c){console.error("rollback",c.message??c.toString()),await _.move(i,r,{overwrite:!0})}}init_empty_value(e){return Z[this.scheme[e]]()}async get_value(e){let i=(await this.get_db())[e];return i==null&&(i=this.init_empty_value(e)),i}async set_value(e,r){const i=await this.get_db();i[e]=r,await this.save_db(i)}}exports.storage_helper=ee;
